patch--- ./github.com/openconfig/gnmi/client/gnmi/client.go	2019-11-22 14:03:29.839103602 -0800
+++ ./github.com/openconfig/gnmi/client/gnmi/client.go	2019-10-11 13:48:49.226145599 -0700
@@ -37,7 +37,6 @@
 	"github.com/openconfig/gnmi/client"
 	"github.com/openconfig/gnmi/client/grpcutil"
 	"github.com/openconfig/gnmi/path"
-	"github.com/openconfig/gnmi/value"
 
 	gpb "github.com/openconfig/gnmi/proto/gnmi"
 )
@@ -246,7 +245,7 @@
 	s := &gpb.SubscribeRequest_Subscribe{
 		Subscribe: &gpb.SubscriptionList{
 			Mode:   getType(q.Type),
-			Prefix: &gpb.Path{Target: q.Target},
+			Prefix: &gpb.Path{Target: q.Target, Origin: q.Origin},
 		},
 	}
 	if q.UpdatesOnly {
@@ -257,11 +256,58 @@
 		if err != nil {
 			return nil, fmt.Errorf("invalid query path %q: %v", qq, err)
 		}
-		s.Subscribe.Subscription = append(s.Subscribe.Subscription, &gpb.Subscription{Path: pp})
+		s.Subscribe.Subscription = append(s.Subscribe.Subscription, &gpb.Subscription{Path: pp, Mode: q.Streaming_type, SampleInterval: q.Streaming_sample_int, HeartbeatInterval: q.Heartbeat_int, SuppressRedundant: q.Suppress_redundant})
 	}
 	return &gpb.SubscribeRequest{Request: s}, nil
 }
 
+// decimalToFloat converts a *gnmi_proto.Decimal64 to a float32. Downcasting to float32 is performed as the
+// precision of a float64 is not required.
+func decimalToFloat(d *gpb.Decimal64) float32 {
+	return float32(float64(d.Digits) / math.Pow(10, float64(d.Precision)))
+}
+
+// ToScalar will convert TypedValue scalar types to a Go native type. It will
+// return an error if the TypedValue does not contain a scalar type.
+func toScalar(tv *gpb.TypedValue) (interface{}, error) {
+	var i interface{}
+	switch tv.Value.(type) {
+	case *gpb.TypedValue_DecimalVal:
+		i = decimalToFloat(tv.GetDecimalVal())
+	case *gpb.TypedValue_StringVal:
+		i = tv.GetStringVal()
+	case *gpb.TypedValue_IntVal:
+		i = tv.GetIntVal()
+	case *gpb.TypedValue_UintVal:
+		i = tv.GetUintVal()
+	case *gpb.TypedValue_BoolVal:
+		i = tv.GetBoolVal()
+	case *gpb.TypedValue_FloatVal:
+		i = tv.GetFloatVal()
+	case *gpb.TypedValue_LeaflistVal:
+		elems := tv.GetLeaflistVal().GetElement()
+		ss := make([]interface{}, len(elems))
+		for x, e := range elems {
+			v, err := toScalar(e)
+			if err != nil {
+				return nil, fmt.Errorf("ToScalar for ScalarArray %+v: %v", e.Value, err)
+			}
+			ss[x] = v
+		}
+		i = ss
+	case *gpb.TypedValue_BytesVal:
+		i = tv.GetBytesVal()
+	case *gpb.TypedValue_JsonIetfVal:
+		var val interface{}
+		val = tv.GetJsonIetfVal()
+		json.Unmarshal(val.([]byte), &i)
+		//i = tv.GetJsonIetfVal()
+	default:
+		return nil, fmt.Errorf("non-scalar type %+v", tv.Value)
+	}
+	return i, nil
+}
+
 func noti(prefix []string, pp *gpb.Path, ts time.Time, u *gpb.Update) (client.Notification, error) {
 	sp := path.ToStrings(pp, false)
 	// Make a full new copy of prefix + u.Path to avoid any reuse of underlying
@@ -274,7 +320,7 @@
 		return client.Delete{Path: p, TS: ts}, nil
 	}
 	if u.Val != nil {
-		val, err := value.ToScalar(u.Val)
+		val, err := toScalar(u.Val)
 		if err != nil {
 			return nil, err
 		}
--- ./github.com/openconfig/gnmi/cmd/gnmi_cli/gnmi_cli.go	2019-11-22 14:03:29.839103602 -0800
+++ ./github.com/openconfig/gnmi/cmd/gnmi_cli/gnmi_cli.go	2019-11-21 09:30:52.453893674 -0800
@@ -76,6 +76,11 @@
 	caCert     = flag.String("ca_crt", "", "CA certificate file. Used to verify server TLS certificate.")
 	clientCert = flag.String("client_crt", "", "Client certificate file. Used for client certificate-based authentication.")
 	clientKey  = flag.String("client_key", "", "Client private key file. Used for client certificate-based authentication.")
+	//Subscribe Options
+	streaming_type = flag.String("streaming_type", "TARGET_DEFINED", "One of TARGET_DEFINED, ON_CHANGE or SAMPLE")
+	streaming_sample_int = flag.Uint("streaming_sample_interval", 0, "Streaming sample inteval seconds, 0 means lowest supported.")
+	heartbeat_int = flag.Uint("heartbeat_interval", 0, "Heartbeat inteval seconds.")
+	suppress_redundant = flag.Bool("suppress_redundant", false, "Suppress Redundant Subscription Updates")
 )
 
 func init() {
@@ -93,6 +98,7 @@
 	flag.StringVar(&cfg.DisplayIndent, "display_indent", "  ", "Output line, per nesting-level indent.")
 	flag.StringVar(&cfg.DisplayType, "display_type", "group", "Display output type (g, group, s, single, p, proto).")
 	flag.StringVar(&q.Target, "target", "", "Name of the gNMI target.")
+	flag.StringVar(&q.Origin, "origin", "", "Name of the gNMI origin.")
 	flag.DurationVar(&q.Timeout, "timeout", 30*time.Second, "Terminate query if no RPC is established within the timeout duration.")
 	flag.StringVar(&cfg.Timestamp, "timestamp", "", "Specify timestamp formatting in output.  One of (<empty string>, on, raw, <FORMAT>) where <empty string> is disabled, on is human readable, raw is int64 nanos since epoch, and <FORMAT> is according to golang time.Format(<FORMAT>)")
 	flag.BoolVar(&cfg.DisplaySize, "display_size", false, "Display the total size of query response.")
@@ -278,6 +284,22 @@
 	if len(*queryFlag) == 0 {
 		return errors.New("--query must be set")
 	}
+	if *streaming_type == "TARGET_DEFINED" {
+		q.Streaming_type = gpb.SubscriptionMode(0)
+	} else if *streaming_type ==  "ON_CHANGE" {
+		q.Streaming_type =  gpb.SubscriptionMode(1)
+	} else if *streaming_type ==  "SAMPLE" {
+		q.Streaming_type = gpb.SubscriptionMode(2)
+	} else {
+		return errors.New("-streaming_type must be one of: (TARGET_DEFINED, ON_CHANGE, SAMPLE)")
+	}
+	q.Streaming_sample_int = uint64(*streaming_sample_int)*uint64(time.Second)
+	if *queryType == "streaming" || *queryType == "s" {
+		q.Heartbeat_int = uint64(*heartbeat_int)*uint64(time.Second)
+	} else if *heartbeat_int > 0  {
+		return errors.New("-heartbeat_interval only valid with streaming query type")
+	}
+	q.Suppress_redundant = bool(*suppress_redundant)
 	for _, path := range *queryFlag {
 		query, err := parseQuery(path, cfg.Delimiter)
 		if err != nil {
--- ./github.com/openconfig/gnmi/client/query.go	2019-11-22 14:03:29.839103602 -0800
+++ ./github.com/openconfig/gnmi/client/query.go	2019-10-11 13:48:49.226145599 -0700
@@ -131,6 +131,8 @@
 	// clients will only handle the first element.
 	Addrs         []string
 	AddressChains [][]string
+	// Origin is the target of the query.
+	Origin string
 	// Target is the target of the query.  Maybe empty if the query is performed
 	// against an end target vs. a collector.
 	Target string
@@ -172,6 +174,10 @@
 	// SubReq is an optional field. If not nil, gnmi client implementation uses
 	// it rather than generating from client.Query while sending gnmi Subscribe RPC.
 	SubReq *gpb.SubscribeRequest
+	Streaming_type gpb.SubscriptionMode
+	Streaming_sample_int uint64
+	Heartbeat_int uint64
+	Suppress_redundant bool
 }
 
 // Destination extracts a Destination instance out of Query fields.
--- ./github.com/openconfig/gnmi/value/value.go	2019-11-22 14:03:29.847103498 -0800
+++ ./github.com/openconfig/gnmi/value/value.go	2019-10-11 13:48:49.234145530 -0700
@@ -117,6 +117,8 @@
 		i = ss
 	case *pb.TypedValue_BytesVal:
 		i = tv.GetBytesVal()
+	case *pb.TypedValue_JsonIetfVal:
+		i = string(tv.GetJsonIetfVal())
 	default:
 		return nil, fmt.Errorf("non-scalar type %+v", tv.Value)
 	}
