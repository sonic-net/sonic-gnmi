// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: sonic_upgrade.proto

package gnoi_sonic

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// State of the update process.
type UpdateFirmwareStatus_State int32

const (
	UpdateFirmwareStatus_STARTED   UpdateFirmwareStatus_State = 0
	UpdateFirmwareStatus_RUNNING   UpdateFirmwareStatus_State = 1
	UpdateFirmwareStatus_SUCCEEDED UpdateFirmwareStatus_State = 2
	UpdateFirmwareStatus_FAILED    UpdateFirmwareStatus_State = 3
)

var UpdateFirmwareStatus_State_name = map[int32]string{
	0: "STARTED",
	1: "RUNNING",
	2: "SUCCEEDED",
	3: "FAILED",
}

var UpdateFirmwareStatus_State_value = map[string]int32{
	"STARTED":   0,
	"RUNNING":   1,
	"SUCCEEDED": 2,
	"FAILED":    3,
}

func (x UpdateFirmwareStatus_State) String() string {
	return proto.EnumName(UpdateFirmwareStatus_State_name, int32(x))
}

func (UpdateFirmwareStatus_State) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ff27221f17e4196b, []int{1, 0}
}

// Request message to start a firmware update.
type UpdateFirmwareRequest struct {
	// Path (inside the server container) or URL to the firmware .bin
	FirmwareSource string `protobuf:"bytes,1,opt,name=firmware_source,json=firmwareSource,proto3" json:"firmware_source,omitempty"`
	// If true, pass UPDATE_MLNX_CPLD_FW="1" to the script (cold-boot vs. warm-reboot).
	UpdateMlnxCpldFw     bool     `protobuf:"varint,2,opt,name=update_mlnx_cpld_fw,json=updateMlnxCpldFw,proto3" json:"update_mlnx_cpld_fw,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateFirmwareRequest) Reset()         { *m = UpdateFirmwareRequest{} }
func (m *UpdateFirmwareRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateFirmwareRequest) ProtoMessage()    {}
func (*UpdateFirmwareRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ff27221f17e4196b, []int{0}
}
func (m *UpdateFirmwareRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateFirmwareRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateFirmwareRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateFirmwareRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateFirmwareRequest.Merge(m, src)
}
func (m *UpdateFirmwareRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdateFirmwareRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateFirmwareRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateFirmwareRequest proto.InternalMessageInfo

func (m *UpdateFirmwareRequest) GetFirmwareSource() string {
	if m != nil {
		return m.FirmwareSource
	}
	return ""
}

func (m *UpdateFirmwareRequest) GetUpdateMlnxCpldFw() bool {
	if m != nil {
		return m.UpdateMlnxCpldFw
	}
	return false
}

// Status message for firmware update progress.
type UpdateFirmwareStatus struct {
	// A human-readable line of output from the script.
	LogLine string                     `protobuf:"bytes,1,opt,name=log_line,json=logLine,proto3" json:"log_line,omitempty"`
	State   UpdateFirmwareStatus_State `protobuf:"varint,2,opt,name=state,proto3,enum=gnoi.sonic.UpdateFirmwareStatus_State" json:"state,omitempty"`
	// If FAILED, propagate one of the script’s exit codes (126–140).
	ExitCode             int32    `protobuf:"varint,3,opt,name=exit_code,json=exitCode,proto3" json:"exit_code,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateFirmwareStatus) Reset()         { *m = UpdateFirmwareStatus{} }
func (m *UpdateFirmwareStatus) String() string { return proto.CompactTextString(m) }
func (*UpdateFirmwareStatus) ProtoMessage()    {}
func (*UpdateFirmwareStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_ff27221f17e4196b, []int{1}
}
func (m *UpdateFirmwareStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateFirmwareStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateFirmwareStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateFirmwareStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateFirmwareStatus.Merge(m, src)
}
func (m *UpdateFirmwareStatus) XXX_Size() int {
	return m.Size()
}
func (m *UpdateFirmwareStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateFirmwareStatus.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateFirmwareStatus proto.InternalMessageInfo

func (m *UpdateFirmwareStatus) GetLogLine() string {
	if m != nil {
		return m.LogLine
	}
	return ""
}

func (m *UpdateFirmwareStatus) GetState() UpdateFirmwareStatus_State {
	if m != nil {
		return m.State
	}
	return UpdateFirmwareStatus_STARTED
}

func (m *UpdateFirmwareStatus) GetExitCode() int32 {
	if m != nil {
		return m.ExitCode
	}
	return 0
}

func init() {
	proto.RegisterEnum("gnoi.sonic.UpdateFirmwareStatus_State", UpdateFirmwareStatus_State_name, UpdateFirmwareStatus_State_value)
	proto.RegisterType((*UpdateFirmwareRequest)(nil), "gnoi.sonic.UpdateFirmwareRequest")
	proto.RegisterType((*UpdateFirmwareStatus)(nil), "gnoi.sonic.UpdateFirmwareStatus")
}

func init() { proto.RegisterFile("sonic_upgrade.proto", fileDescriptor_ff27221f17e4196b) }

var fileDescriptor_ff27221f17e4196b = []byte{
	// 360 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x91, 0xcf, 0x4e, 0xea, 0x40,
	0x14, 0xc6, 0x19, 0x08, 0xff, 0xce, 0x0d, 0xdc, 0x66, 0xb8, 0x37, 0xe1, 0x5e, 0x93, 0x5a, 0xbb,
	0x50, 0x36, 0x56, 0x83, 0x4b, 0xd9, 0x60, 0x5b, 0x0c, 0x09, 0xb2, 0x68, 0xe9, 0x42, 0x37, 0x93,
	0xda, 0x0e, 0x4d, 0x93, 0xd2, 0xa9, 0xed, 0x54, 0x78, 0x14, 0x1f, 0xc9, 0xb8, 0xf2, 0x11, 0x0c,
	0xbe, 0x88, 0xe9, 0x00, 0x31, 0x24, 0x1a, 0x57, 0x93, 0xf9, 0x9d, 0xf9, 0xbe, 0xf3, 0x9d, 0x33,
	0xd0, 0xc9, 0x58, 0x1c, 0x7a, 0x24, 0x4f, 0x82, 0xd4, 0xf5, 0xa9, 0x96, 0xa4, 0x8c, 0x33, 0x0c,
	0x41, 0xcc, 0x42, 0x4d, 0x54, 0x54, 0x06, 0x7f, 0x9d, 0xc4, 0x77, 0x39, 0x1d, 0x85, 0xe9, 0x62,
	0xe9, 0xa6, 0xd4, 0xa2, 0x0f, 0x39, 0xcd, 0x38, 0x3e, 0x81, 0xdf, 0xf3, 0x2d, 0x22, 0x19, 0xcb,
	0x53, 0x8f, 0x76, 0x91, 0x82, 0x7a, 0x4d, 0xab, 0xbd, 0xc3, 0xb6, 0xa0, 0xf8, 0x14, 0x3a, 0xb9,
	0x70, 0x20, 0x8b, 0x28, 0x5e, 0x11, 0x2f, 0x89, 0x7c, 0x32, 0x5f, 0x76, 0xcb, 0x0a, 0xea, 0x35,
	0x2c, 0x69, 0x53, 0xba, 0x89, 0xe2, 0x95, 0x9e, 0x44, 0xfe, 0x68, 0xa9, 0xbe, 0x20, 0xf8, 0xb3,
	0xdf, 0xd1, 0xe6, 0x2e, 0xcf, 0x33, 0xfc, 0x0f, 0x1a, 0x11, 0x0b, 0x48, 0x14, 0xc6, 0xbb, 0x4e,
	0xf5, 0x88, 0x05, 0x93, 0x30, 0xa6, 0x78, 0x00, 0xd5, 0x8c, 0xbb, 0x9c, 0x0a, 0xd3, 0x76, 0xff,
	0x58, 0xfb, 0x1c, 0x40, 0xfb, 0xca, 0x4b, 0x2b, 0x0e, 0x6a, 0x6d, 0x44, 0xf8, 0x00, 0x9a, 0x74,
	0x15, 0x72, 0xe2, 0x31, 0x9f, 0x76, 0x2b, 0x0a, 0xea, 0x55, 0xad, 0x46, 0x01, 0x74, 0xe6, 0x53,
	0x75, 0x00, 0x55, 0xf1, 0x18, 0xff, 0x82, 0xba, 0x3d, 0x1b, 0x5a, 0x33, 0xd3, 0x90, 0x4a, 0xc5,
	0xc5, 0x72, 0xa6, 0xd3, 0xf1, 0xf4, 0x5a, 0x42, 0xb8, 0x05, 0x4d, 0xdb, 0xd1, 0x75, 0xd3, 0x34,
	0x4c, 0x43, 0x2a, 0x63, 0x80, 0xda, 0x68, 0x38, 0x9e, 0x98, 0x86, 0x54, 0xe9, 0x27, 0xd0, 0xb1,
	0x8b, 0x14, 0xce, 0x66, 0xbf, 0x36, 0x4d, 0x1f, 0x43, 0x8f, 0xe2, 0x5b, 0x68, 0xef, 0xc7, 0xc2,
	0x47, 0xdf, 0x47, 0xde, 0x2e, 0xfc, 0xbf, 0xf2, 0xd3, 0x54, 0x6a, 0xe9, 0x1c, 0x5d, 0x1d, 0x3e,
	0xaf, 0x65, 0xf4, 0xba, 0x96, 0xd1, 0xdb, 0x5a, 0x46, 0x4f, 0xef, 0x72, 0xe9, 0xae, 0xa5, 0x9d,
	0x5d, 0x16, 0x4a, 0x22, 0x94, 0xf7, 0x35, 0xf1, 0xc7, 0x17, 0x1f, 0x01, 0x00, 0x00, 0xff, 0xff,
	0xdc, 0x29, 0xb2, 0xec, 0xfa, 0x01, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// SonicUpgradeServiceClient is the client API for SonicUpgradeService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type SonicUpgradeServiceClient interface {
	// Starts a firmware update and streams status/log lines back to the client.
	UpdateFirmware(ctx context.Context, in *UpdateFirmwareRequest, opts ...grpc.CallOption) (SonicUpgradeService_UpdateFirmwareClient, error)
}

type sonicUpgradeServiceClient struct {
	cc *grpc.ClientConn
}

func NewSonicUpgradeServiceClient(cc *grpc.ClientConn) SonicUpgradeServiceClient {
	return &sonicUpgradeServiceClient{cc}
}

func (c *sonicUpgradeServiceClient) UpdateFirmware(ctx context.Context, in *UpdateFirmwareRequest, opts ...grpc.CallOption) (SonicUpgradeService_UpdateFirmwareClient, error) {
	stream, err := c.cc.NewStream(ctx, &_SonicUpgradeService_serviceDesc.Streams[0], "/gnoi.sonic.SonicUpgradeService/UpdateFirmware", opts...)
	if err != nil {
		return nil, err
	}
	x := &sonicUpgradeServiceUpdateFirmwareClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type SonicUpgradeService_UpdateFirmwareClient interface {
	Recv() (*UpdateFirmwareStatus, error)
	grpc.ClientStream
}

type sonicUpgradeServiceUpdateFirmwareClient struct {
	grpc.ClientStream
}

func (x *sonicUpgradeServiceUpdateFirmwareClient) Recv() (*UpdateFirmwareStatus, error) {
	m := new(UpdateFirmwareStatus)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// SonicUpgradeServiceServer is the server API for SonicUpgradeService service.
type SonicUpgradeServiceServer interface {
	// Starts a firmware update and streams status/log lines back to the client.
	UpdateFirmware(*UpdateFirmwareRequest, SonicUpgradeService_UpdateFirmwareServer) error
}

// UnimplementedSonicUpgradeServiceServer can be embedded to have forward compatible implementations.
type UnimplementedSonicUpgradeServiceServer struct {
}

func (*UnimplementedSonicUpgradeServiceServer) UpdateFirmware(req *UpdateFirmwareRequest, srv SonicUpgradeService_UpdateFirmwareServer) error {
	return status.Errorf(codes.Unimplemented, "method UpdateFirmware not implemented")
}

func RegisterSonicUpgradeServiceServer(s *grpc.Server, srv SonicUpgradeServiceServer) {
	s.RegisterService(&_SonicUpgradeService_serviceDesc, srv)
}

func _SonicUpgradeService_UpdateFirmware_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(UpdateFirmwareRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SonicUpgradeServiceServer).UpdateFirmware(m, &sonicUpgradeServiceUpdateFirmwareServer{stream})
}

type SonicUpgradeService_UpdateFirmwareServer interface {
	Send(*UpdateFirmwareStatus) error
	grpc.ServerStream
}

type sonicUpgradeServiceUpdateFirmwareServer struct {
	grpc.ServerStream
}

func (x *sonicUpgradeServiceUpdateFirmwareServer) Send(m *UpdateFirmwareStatus) error {
	return x.ServerStream.SendMsg(m)
}

var _SonicUpgradeService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "gnoi.sonic.SonicUpgradeService",
	HandlerType: (*SonicUpgradeServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "UpdateFirmware",
			Handler:       _SonicUpgradeService_UpdateFirmware_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "sonic_upgrade.proto",
}

func (m *UpdateFirmwareRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateFirmwareRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateFirmwareRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UpdateMlnxCpldFw {
		i--
		if m.UpdateMlnxCpldFw {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.FirmwareSource) > 0 {
		i -= len(m.FirmwareSource)
		copy(dAtA[i:], m.FirmwareSource)
		i = encodeVarintSonicUpgrade(dAtA, i, uint64(len(m.FirmwareSource)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateFirmwareStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateFirmwareStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateFirmwareStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ExitCode != 0 {
		i = encodeVarintSonicUpgrade(dAtA, i, uint64(m.ExitCode))
		i--
		dAtA[i] = 0x18
	}
	if m.State != 0 {
		i = encodeVarintSonicUpgrade(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x10
	}
	if len(m.LogLine) > 0 {
		i -= len(m.LogLine)
		copy(dAtA[i:], m.LogLine)
		i = encodeVarintSonicUpgrade(dAtA, i, uint64(len(m.LogLine)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintSonicUpgrade(dAtA []byte, offset int, v uint64) int {
	offset -= sovSonicUpgrade(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *UpdateFirmwareRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FirmwareSource)
	if l > 0 {
		n += 1 + l + sovSonicUpgrade(uint64(l))
	}
	if m.UpdateMlnxCpldFw {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateFirmwareStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.LogLine)
	if l > 0 {
		n += 1 + l + sovSonicUpgrade(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovSonicUpgrade(uint64(m.State))
	}
	if m.ExitCode != 0 {
		n += 1 + sovSonicUpgrade(uint64(m.ExitCode))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovSonicUpgrade(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozSonicUpgrade(x uint64) (n int) {
	return sovSonicUpgrade(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *UpdateFirmwareRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSonicUpgrade
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateFirmwareRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateFirmwareRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirmwareSource", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSonicUpgrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSonicUpgrade
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSonicUpgrade
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirmwareSource = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateMlnxCpldFw", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSonicUpgrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateMlnxCpldFw = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSonicUpgrade(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSonicUpgrade
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateFirmwareStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSonicUpgrade
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateFirmwareStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateFirmwareStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogLine", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSonicUpgrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSonicUpgrade
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSonicUpgrade
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LogLine = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSonicUpgrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= UpdateFirmwareStatus_State(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExitCode", wireType)
			}
			m.ExitCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSonicUpgrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExitCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSonicUpgrade(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSonicUpgrade
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSonicUpgrade(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSonicUpgrade
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSonicUpgrade
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSonicUpgrade
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthSonicUpgrade
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupSonicUpgrade
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthSonicUpgrade
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthSonicUpgrade        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSonicUpgrade          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupSonicUpgrade = fmt.Errorf("proto: unexpected end of group")
)
